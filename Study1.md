# Chap01-ORM, JPA

### ○ ORM(Object Relational Mapping)

: 객체-관계 매핑

객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것


* **ORM을 사용하면 DataBase를 몰라도 상관없는가?** 그렇지 않음

ORM을 사용하기 위해선 DataBase와 OOP에 대해 모두 잘 알고 있어야 한다. ORM을 이용할 때 결국 영속성을 가진 객체는 DataBase에 저장된다.
테이블 설계도 중요하며, ORM을 사용할 때 가장 중요한 것 중 하나는 테이블과 객체의 매핑을 하는 것이다.
그렇기 때문에 ORM을 사용할 DataBase와 OOP를 모두 잘 알고 있는 게 좋다.


* **DataBase(SQL)을 직접 다룰 때 발생하는 문제점**

- [x] 코드의 반복이 발생
- [x] SQL에 의존적인 개발


* **ORM vs DB**
![image](https://user-images.githubusercontent.com/110509654/211352195-954686a8-acbf-487d-bde2-9199e60049cf.png)



* **ORM의 장점**
1. 객체 지향적이기 때문에 개발자가 비즈니스 로직 및 코드 자체에 집중할 수 있다.
2. 관념적 코드(Boilerplate code)가 없거나 적어진다.
3. 코드의 재사용, 유지보수가 편하다.
4. DBMS의 종속성이 줄어든다.


* **ORM의 단점**
1. N+1 문제 등 해결해야 할 과제가 있다.
2. 생성되는 쿼리 속도등의 문제가 있다.
3. 설계가 잘못되면 일관성이 무너지거나 성능 저하의 문제가 있다.


### ○ JPA(Java Persistence API) - Java의 ORM 표준 기술
Application과 JDBC 사이에서 동작한다.

![image](https://user-images.githubusercontent.com/110509654/211352841-c10a565c-b356-4ed7-a951-bc109f6deb01.png)

* **JPA를 사용해야 하는 이유**
1. 생산성의 향상
2. 유지보수성의 향상
3. 패러다임의 불일치 해결
4. 성능
5. 데이터 접근의 추상화와 벤더 독립성


* **JPA의 구현체**
1. Hibernate
2. Spring Data JPA
- JPA를 한 단계 추상화시킨 Repository 인터페이스 제공


# Chap02-객체 매핑, 엔티티 매니저

* **@Entity** :
이 클래스를 테이블과 매핑한다고 JPA에게 알려주는 어노테이션
@Entity 어노테이션이 있는 클래스를 엔티티 클래스라고 한다.

* **@Table** :
엔티티 클래스에 매핑할 테이블 정보를 알려준다.
name 속성을 이용하여 테이블 명을 지정한다.
name 속성이 생략되어 있다면 클래스의 이름(엔티티의 이름)을 테이블 이름으로 매핑한다.

* **@Id** :
엔티티 클래스의 필드를 테이블의 기본키(Primary key, PK)에 매핑한다.
@Id 가 사용된 필드를 식별자 필드라고 한다.

* **@Column** :
필드를 컬럼에 매핑한다.

* **엔티티 매니저**
특정작업을 위해서 데이터베이스에 액세스하는 역할을 담당. 엔티티를 DB에 등록, 수정, 삭제, 조회(CRUD) 하는 역할.
이름 그대로 엔티티와 관련된 일을 처리하는 엔티티 관리자이다.

***엔티티 매니저 사용 주의사항***
1. 엔티티 매니저 팩토리는 설정 정보를 읽어와 DB커넥션 풀도 생성하기 때문에 엔티티 매니저 팩토리의 생성비용은 아주 크다. 따라서 엔티티 매니저 팩토리는 어플리케이션 전체에서 딱 한번만 생성하고 공유해서 사용해야 한다.
2. 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드간에 공유하거나 재사용하면 안된다.
3. 사용이 끝난 엔티티 매니저는 반드시 종료해야 한다.

# Chap03-영속성 관리
![image](https://user-images.githubusercontent.com/110509654/211354785-94b29cd9-cb68-4e27-8ae2-19ecc3872f8b.png)




